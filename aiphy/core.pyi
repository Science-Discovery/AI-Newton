from typing import List, Dict, Set, Tuple
from deprecated.sphinx import deprecated


def search_relations_ver3(ds: DataStruct, debug: bool = False, cpu_num: int = 50) -> List[Tuple[Exp, ExpData]]:
    """
    对于给定的数据 f(t), g(t), ... ，
    提取出所有形如
    h1(t) o h2(t), f1(t)g1(t) o h(t), f1(t)g1(t) o f2(t)g2(t),
    f1(t)g1(t)^2 +/- f2(t)g2(t)^2 的守恒量
    这里的 o 表示二元运算符， 包括加减乘除和求导
    """
    ...

def search_trivial_relations(ds: DataStruct, debug: bool = False) -> List[Tuple[Exp, ExpData]]:
    """
    对于给定的数据 f(t), ... ， 提取出所有形如 f(t), f'(t) 的守恒量
    """
    ...

def search_relations_ver1(ds: DataStruct, debug: bool = False, cpu_num: int = 50) -> List[Tuple[Exp, ExpData]]:
    """
    对于给定的数据 f(t), g(t), ... ，
    提取出所有形如 f(t) o g(t) 的守恒量（这里的 f(t) 和 g(t) 被要求是非守恒的）
    包括求导 D[f(t)]/D[g(t)] 形式的非平凡守恒量 （ D[f(t)]/D[t] != const )
    """
    ...

def search_relations_ver2(ds: DataStruct, debug: bool = False, cpu_num: int = 50) -> List[Tuple[Exp, ExpData]]:
    """
    对于给定的数据 f(t), g(t), ... ，
    提取出所有形如 h1(t) o h2(t), f1(t)g1(t) o h(t) 或 f1(t)g1(t) o f2(t)g2(t) 的守恒量
    这里的 o 表示二元运算符， 包括加减乘除和求导，包括有理线性组合。
    """
    ...

def search_binary_relations(ds: DataStruct, debug: bool = False, cpu_num: int = 50) -> List[Tuple[Exp, ExpData]]:
    """
    search_relations 的不包括求导的版本
    """
    ...

class Knowledge:
    ...
    @classmethod
    def default(cls) -> Knowledge:
        """
        Create a default knowledge object with builtin experiments implemented.
        """
        ...
    def __str__(self) -> str: ...
    def parse_from(content: str) -> Knowledge: ...

    # Print the information of the knowledge
    def list_experiments(self): ...
    def list_concepts(self): ...
    def list_conclusions(self): ...

    # Get the information of the knowledge
    @property
    def fetch_experiments(self) -> List[str]: ...
    @property
    def fetch_concepts(self) -> Dict[str, Expression]: ...
    @property
    def fetch_intrinsic_concepts(self) -> Dict[str, Intrinsic]: ...
    @property
    def fetch_conclusions(self) -> Dict[str, Proposition]: ...
    def fetch_concept_by_name(self, name: str) -> Expression: ...
    def fetch_conclusion_by_name(self, name: str) -> Proposition: ...
    def fetch_object_keys(self) -> Set[str]: ...
    def fetch_object_by_name(self, name: str) -> Objstructure: ...
    def fetch_object_type_by_name(self, name: str) -> str: ...

    # register new knowledge to the current object
    def register_experiment(self, name: str, exp: ExpStructure): ...
    def register_basic_concept(self, concept: Concept): ...
    def register_expression(self, name: str, exp: Expression) -> bool: ...
    def find_similar_conclusion(self, prop: Proposition) -> str | None: ...
    def find_similar_intrinsic(self, intrinsic: Intrinsic) -> str | None: ...
    def find_similar_concept(self, concept: Concept) -> str | None: ...
    def register_conclusion(self, name: str, prop: Proposition) -> bool: ...
    def register_object(self, name: str, obj: Objstructure) -> bool: ...
    def remove_conclusion(self, name: str): ...
    def remove_concept(self, name: str): ...
    def remove_object(self, name: str): ...

    def fetch_expstruct(self, name: str) -> ExpStructure: ...
    def fetch_objstructure_in_expstruct(self, expname: str, objid: int) -> Objstructure: ...
    def get_expstructure(self, expconfig: IExpConfig, objsettings: List[Objstructure]) -> ExpStructure: ...
    def eval_intrinsic(self, intrinsic: Intrinsic, objsettings: List[Objstructure]) -> ConstData: ...

    def eval(self, exp: Exp, context: ExpStructure) -> ExpData: ...

    def eval_expr_key(self, expr: Expression) -> KeyValueHashed: ...
    def eval_exp_keyvalue(self, exp: Exp, exp_name: str | None) -> KeyValue: ...
    def eval_exp_keyvaluehashed(self, exp: Exp, exp_name: str | None) -> KeyValueHashed: ...

    def generalize_sexp(self, sexp: SExp) -> Concept | None: ...
    def generalize(self, expr: Exp, exp_name: str) -> Concept | None: ...
    def generalize_to_normal_concept(self, expr: Exp, exp_name: str) -> Concept | None: ...
    def extract_concepts(self, expr: Exp, exp_name: str) -> Set[Concept]: ...
    def specialize(self, concept: Concept, exp_name: str) -> List[Exp]: ...
    def specialize_concept(self, concept_name: str, exp_name: str) -> List[AtomExp]: ...
    def raw_definition(self, expr: Expression, exp_name: str | None) -> Expression: ...
    def raw_definition_prop(self, prop: Proposition, exp_name: str | None) -> Proposition: ...
    def raw_definition_exp(self, exp: Exp, exp_name: str | None) -> Exp: ...

    def parse_atomexp_to_sympy_str(self, input: AtomExp, argument: str) -> str: ...
    def parse_exp_to_sympy_str(self, input: Exp, argument: str) -> str: ...

    def dependence_of_exp(self, exp: Exp) -> Set[str]: ...
    def dependence_of_sexp(self, sexp: SExp) -> Set[str]: ...
    def dependence_of_concept(self, concept: Concept) -> Set[str]: ...
    def dependence_of_intrinsic(self, intrinsic: Intrinsic) -> Set[str]: ...
    def dependence_of_proposition(self, prop: Proposition) -> Set[str]: ...
    def dependence_of_expconfig(self, iexpconfig: IExpConfig) -> Set[str]: ...
    def dependence_of_atomexp(self, atomexp: AtomExp) -> Set[str]: ...

    def obliviate(self, useful_names: Set[str]): ...

    def gen_atom_concept_by_name(self, name: str) -> Concept: ...
    def check_geometry_info(self, context: ExpStructure) -> bool: ...


class ExpConfig:
    ...
    def __new__(cls, name: str, spdim: int,
                exp_para: Dict[str, Parastructure],
                obj_info: Dict[str, Objstructure],
                data_info: List[Tuple[Concept, List[str]]],
                ) -> ExpConfig: ...
    def para(self, para_name: str) -> Parastructure: ...
    def obj_para(self, obj_name: str, para_name: ATTR) -> Parastructure: ...
    def get_obj_para(self, obj_name: str, para_name: str) -> Parastructure: ...
    @property
    def original_data(self) -> List[AtomExp]: ...   # 实验的原始测量数据的名字，如 t[0], posx[1] 等
    @property
    def original_concept(self) -> Set[Concept]: ...   # 实验的原始测量数据对应的原始概念，如 posx, t 等
    def new_datastruct_of_doexperiment(self, t_num: int) -> DataStructOfDoExperiment: ...
    def random_settings(self): ...
    def gen_exp(self, content: str) -> Exp: ...
    def gen_prop(self, content: str) -> Proposition: ...
    def register_geometry_info(self, prop: Proposition): ...
    def print_geometry_info(self): ...

class DataStructOfDoExperiment:
    ...
    def insert_data(self, key: Tuple[Concept, List[str]], data: List[float]): ...
    @property
    def n(self) -> int: ...
    @property
    def obj_id_map(self) -> Dict[str, Tuple[ObjType, int]]: ...
    @property
    def data(self) -> Dict[AtomExp, List[float]]: ...


class ExpStructure:
    """
    一个数据结构，包括实验的配置信息，以及测量数据结果。
    """
    ...
    def __new__(cls, exp_config: ExpConfig, do_experiment: DoExpType) -> ExpStructure: ...
    @property
    def all_ids(self) -> Set[int]: ...
    def get_obj_type(self, id: int) -> str: ...
    def get_obj(self, id: int) -> Objstructure: ...
    @property
    def obj_info(self) -> Dict[str, Tuple[ObjType, int]]: ...
    @property
    def data_info(self) -> DataStruct: ...
    @property
    def exp_name(self) -> str: ...
    @property
    def spdim(self) -> int: ...

    def random_settings(self): ...
    def random_set_exp_para(self): ...
    def random_set_obj(self, id: int): ...
    def set_obj(self, id: int, obj: Objstructure): ...
    def collect_expdata(self, measure_type: MeasureType) -> DataStructOfExpData: ...

    def copy(self) -> ExpStructure: ...

    @property
    def original_data(self) -> List[AtomExp]: ...   # 实验的原始测量数据的名字，如 t[0], posx[1] 等
    @property
    def original_concept(self) -> Set[Concept]: ...   # 实验的原始测量数据对应的原始概念，如 posx, t 等
    @property
    def geometry_info(self) -> List[Proposition]: ...  # 实验的原始测量数据对应的原始概念，如 posx, t 等
    def print_geometry_info(self): ...

class ObjType:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> ObjType: ...

class Objstructure:
    ...
    def __new__(cls, content: str) -> Objstructure: ...
    def __str__(self) -> str: ...
    def random_settings(self): ...

    # buildin object structures
    @classmethod
    def make_particle(cls, m_low, m_high) -> Objstructure: ...
    @classmethod
    def make_elec_particle(cls, m_low, m_high, e_low, e_high) -> Objstructure: ...
    @classmethod
    def make_spring(cls, k_low, k_high, l_low, l_high) -> Objstructure: ...
    @classmethod
    def clock(cls) -> Objstructure: ...
    @classmethod
    def make_slope(cls) -> Objstructure: ...

class Parastructure:
    ...
    def __new__(cls, content: str) -> Parastructure: ...
    def __str__(self) -> str: ...

class MeasureType:
    ...
    @classmethod
    def default(cls) -> MeasureType:
        """
        MeasureType {
            n: 100,
            repeat_time: 100,
            error: 1e-8,
            t_end: 2.0,
        }
        """
        ...
    @property
    def n(self) -> int: ...
    @property
    def repeat_time(self) -> int: ...
    @property
    def error(self) -> float: ...
    @property
    def t_end(self) -> float: ...

class DoExpType:
    ...
    def __new__(cls, filename: str) -> DoExpType: ...

class DataStruct:
    ...
    def __str__(self) -> str: ...
    @classmethod
    def empty(cls) -> DataStruct: ...

    @property
    def data_keys(self) -> Set[AtomExp]: ...

    def fetch_data_by_name_ids(self, name: str, ids: List[int]) -> ExpData: ...
    def fetch_data_by_key(self, atom: AtomExp) -> ExpData: ...
    def fetch_data_by_str(self, key: str) -> ExpData: ...

    def add_data(self, atom: AtomExp, data: ExpData): ...
    def remove_data(self, atom: AtomExp): ...

class DataStructOfExpData:
    ...
    def datastruct(self) -> DataStruct: ...

class AtomExp:
    """
    Represents an atomic expression in the language of the AI Physicist.
    For example, "pos[1]", "r[2, 3]", "t[0]" are all atomic expressions.
    """

    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...

    @classmethod
    def __new__(cls, content: str) -> AtomExp: ...
    @classmethod
    def VariableIds(cls, name: str, ids: List[int]) -> AtomExp:
        """
        Create an atomic expression with a variable name and a list of ids.
        For example AtomExp.VariableIds("x", [1, 2]) represents "x[1, 2]". 
        """
        ...

    @classmethod
    def get_t(cls) -> AtomExp:
        """
        Get t[0] as an AtomExp.
        In general, we default the time variable to t[0],
        to indicate that the number of the “clock” is 0.
        """
        ...

    @property
    def name(self) -> str: ...
    @property
    def vec_ids(self) -> List[int]:
        """get the ordered ids of the atomic expression"""
        ...
    @property
    def allids(self) -> Set[int]: ...
    def substs(self, subs: Dict[int, int]) -> AtomExp: ...

class ATTR:
    ...
    def __new__(obj: ObjType, name: str) -> ATTR: ...
    def __str__(self) -> str: ...

class DATA:
    ...
    @staticmethod
    def particle_posx() -> Concept: ...
    @staticmethod
    def particle_posy() -> Concept: ...
    @staticmethod
    def particle_posz() -> Concept: ...
    @staticmethod
    def particle_dist() -> Concept: ...
    @staticmethod
    def spring_length() -> Concept: ...
    @staticmethod
    def clock_time() -> Concept: ...
    @staticmethod
    def slope_cx() -> Concept: ...
    @staticmethod
    def slope_cy() -> Concept: ...
    @staticmethod
    def slope_cz() -> Concept: ...

class Exp:
    """
    Represents an expression in the language of the AI Physicist.
    Such as "posx[1] + posy[2]", "D[posx[1]]/D[t]", "posx[1] - posy[2]".
    """
    ...

    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> Exp: ...
    @classmethod
    def Number(cls, i: int) -> Exp: ...
    @classmethod
    def Atom(cls, atom: AtomExp) -> Exp: ...
    @classmethod
    def Partial(cls, exp: Exp, atom: AtomExp) -> Exp: ...
    @classmethod
    def DiffExp(cls, exp1: Exp, exp2: Exp, ord: int) -> Exp: ...

    def copy(self) -> Exp: ...
    @property
    def type(self) -> str: ...
    @property
    def unwrap_atom(self) -> AtomExp: ...
    @property
    def unwrap_partial(self) -> Tuple[Exp, AtomExp]: ...
    @property
    def complexity(self) -> int: ...
    @classmethod
    def new_variable(cls, name: str) -> Exp: ...
    @classmethod
    def new_variable_ids(cls, name: str, ids: List[int]) -> Exp: ...
    @classmethod
    def get_t(cls) -> Exp: ...

    def subst_by_dict(self, subs: Dict[int, int]) -> Exp: ...
    def replace_atom_by_exp(self, atom: AtomExp, exp: Exp) -> Exp: ...
    def replace_partial_by_exp(self, partial_exp: Exp, exp: Exp) -> Exp: ...

    @property
    def allids(self) -> Set[int]: ...
    @property
    def all_atoms(self) -> Set[AtomExp]: ...
    @property
    def all_partials(self) -> Set[Exp]: ...

    def doit(self) -> Exp:
        """
        Simplify the expression to normal form.
        """
        ...

    def __add__(self, other: Exp) -> Exp: ...
    def __sub__(self, other: Exp) -> Exp: ...
    def __mul__(self, other: Exp) -> Exp: ...
    def __rmul__(self, other: int) -> Exp: ...
    def __truediv__(self, other: Exp) -> Exp: ...
    def __neg__(self) -> Exp: ...
    def __powi__(self, other: int) -> Exp: ...
    def __diff__(self, other: Exp) -> Exp: ...
    def __difft__(self, ord: int) -> Exp: ...
    def __partial__(self, other: AtomExp) -> Exp: ...

class Concept:
    """
    Give a type hint for the `Exp`, to make it a `concept`.
    Such as "(1 -> Particle) (2 -> String) |- posx[1] / posr[2]"
    A `concept` can be `specialized` to an `Exp` in a specific experiment.
    """
    ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...

    def __add__(self, other: Concept) -> Concept: ...
    def __sub__(self, other: Concept) -> Concept: ...
    def __mul__(self, other: Concept) -> Concept: ...
    def __rmul__(self, other: int) -> Concept: ...
    def __truediv__(self, other: Concept) -> Concept: ...
    def __neg__(self) -> Concept: ...
    def __powi__(self, other: int) -> Concept: ...
    def __difft__(self, ord: int) -> Concept: ...
    def __partial__(self, other: Concept) -> Concept: ...

    def __new__(cls, content: str) -> Concept: ...
    @classmethod
    def Mk0(cls, exp: Exp) -> Concept: ...
    @classmethod
    def Mksucc(cls, objtype: str, concept: Concept, id: int) -> Concept: ...
    @classmethod
    def Mksum(cls, objtype: str, concept: Concept) -> Concept: ...

    def subst_by_vec(self, subs: List[int]) -> Exp: ...
    def subst_by_dict(self, subs: Dict[int, int]) -> Exp: ...
    @property
    def exp(self) -> Exp: ...
    @property
    def preids(self) -> List[int]: ...
    @property
    def is_sum(self) -> bool: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...
    @property
    def atomexp_name(self) -> str: ...
    @property
    def pre_objtype_id_vec(self) -> List[Tuple[str, int]]: ...
    @property
    def complexity(self) -> int: ...

class IExpConfig:
    """
    When we concentrate on a experiment, we can identify the object type and the id.
    `Mkfix` means the the object#id is fixed to `object_name` (refered as standard object).
    `Mk` means the object#id is not fixed, and we can substitute it with any given object of `object_type`
    """
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> IExpConfig: ...
    @classmethod
    def From(cls, exp_name: str) -> IExpConfig: ...
    @classmethod
    def Mk(cls, object_type: str, iexpconfig: IExpConfig, id: int) -> IExpConfig: ...
    @classmethod
    def Mkfix(cls, object_name: str, iexpconfig: IExpConfig, id: int) -> IExpConfig: ...

    @property
    def expname(self) -> str: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...
    @property
    def preids(self) -> List[int]: ...
    @property
    def get_relevant_objs(self) -> List[str]: ...

class SExp:
    """
    Combine Expconfig and Exp together, to represent a specialized expression.
    """
    ...
    def __str__(self) -> str: ...

    def __new__(cls, content: str) -> SExp: ...
    @classmethod
    def Mk(cls, iexpconfig: IExpConfig, exp: Exp) -> SExp: ...

    @property
    def expconfig(self) -> IExpConfig: ...
    @property
    def exp(self) -> Exp: ...
    @property
    def objtype_id_map(self) -> Dict[str, Set[int]]: ...
    @property
    def get_relevant_objs(self) -> List[str]: ...

class Intrinsic:
    """
    Represent an object attribute expression.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Intrinsic: ...
    @classmethod
    def From(cls, sexp: SExp) -> Intrinsic: ...
    def __neg__(self) -> Intrinsic: ...
    def __inv__(self) -> Intrinsic: ...

    @property
    def relevant_objs(self) -> List[str]: ...
    @property
    def measure_experiment(self) -> str: ...
    @property
    def input_objids(self) -> List[int]: ...
    @property
    def input_objtypes(self) -> List[ObjType]: ...

class Proposition:
    """
    Represent a proposition in the language of the AI Physicist.
    """
    ...
    def __str__(self) -> str: ...
    @classmethod
    def __new__(cls, content: str) -> Proposition: ...
    @classmethod
    def IsZero(cls, exp: Exp) -> Proposition: ...
    @classmethod
    def IsConserved(cls, exp: Exp) -> Proposition: ...
    @classmethod
    def Zero(cls, concept: Concept) -> Proposition: ...
    @classmethod
    def Conserved(cls, concept: Concept) -> Proposition: ...

    @property
    def prop_type(self) -> str: ...
    @property
    def unwrap_exp(self) -> Exp: ...
    @property
    def unwrap_concept(self) -> Concept: ...
    @property
    def unwrap_intrinsic(self) -> Intrinsic: ...
    @property
    def unwrap_proposition(self) -> Proposition: ...
    @property
    def complexity(self) -> int: ...
    @property
    def is_zero(self) -> bool: ...
    @property
    def is_conserved(self) -> bool: ...
    # not implemented yet

class Expression:
    """
    This class gathers all possible types of expression.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, content: str) -> Expression: ...
    @classmethod
    def Exp(cls, exp: Exp) -> Expression: ...
    @classmethod
    def SExp(cls, sexp: SExp) -> Expression: ...
    @classmethod
    def Concept(cls, concept: Concept) -> Expression: ...
    @classmethod
    def Intrinsic(cls, intrinsic: Intrinsic) -> Expression: ...
    @classmethod
    def Proposition(cls, prop: Proposition) -> Expression: ...
    @property
    def expr_type(self) -> str: ...
    @property
    def unwrap_exp(self) -> Exp: ...
    @property
    def unwrap_sexp(self) -> SExp: ...
    @property
    def unwrap_concept(self) -> Concept: ...
    @property
    def unwrap_intrinsic(self) -> Intrinsic: ...
    @property
    def unwrap_proposition(self) -> Proposition: ...


class KeyValue:
    @property
    def is_none(self) -> bool: ...
    @property
    def is_const(self) -> bool: ...
    @property
    def is_zero(self) -> bool: ...


class KeyValueHashed:
    @classmethod
    def none(cls, value_len: int, p_mod: int) -> KeyValueHashed: ...
    @property
    def is_none(self) -> bool: ...
    @property
    def is_const(self) -> bool: ...
    @property
    def is_zero(self) -> bool: ...
    @property
    def is_trivial_const(self) -> bool: ...
    @property
    def data(self) -> List[int]: ...

    def insert_description(self, desc: str): ...
    def neg(self) -> KeyValueHashed: ...
    def inv(self) -> KeyValueHashed: ...


class ExpData:
    """
    The major class to represent the data measured in an experiment.
    There are four cases of data:
    1. NormalData: data with noise, with size (n, repeat_time).
    2. ConstData: conserved data (not zero), with mean and std.
    3. ZeroData: zero data.
    4. ErrData: data that has error information (probabily due to crashes between calculations).
    ExpData supports basic operations like +, -, *, /, __powi__.
    ExpData also supports differential operations like __diff__, __difftau__.
    """
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> ExpData: ...
    @property
    def is_conserved(self) -> bool: ... # const or zero
    @property
    def is_const(self) -> bool: ...
    @property
    def is_zero(self) -> bool: ...
    @property
    def is_err(self) -> bool: ...
    @property
    def is_normal(self) -> bool: ...
    @property
    def const_data(self) -> ConstData: ...
    @property
    def normal_data(self) -> NormalData: ...
    @property
    def force_to_const_data(self) -> ConstData | None:
        """
        Transform a ExpData to its (weighted_mean, weighted_std) representation.
        If `ExpData.is_err`, then return None.
        This function is useful when we assume a ExpData is conserved and try to extract its ConstData representation.
        """
        ...
    @property
    def calc_mean(self) -> ConstData | None:
        """
        Calculate the mean of the data (not weighted), and estimate its error.
        This function is also useful for NormalData, which can be non-conserved.
        """
        ...
    @classmethod
    def from_elem(cls, mean: float, std: float, n: int, repeat_time: int) -> ExpData: ...
    @property
    def n(self) -> int: ...
    @property
    def repeat_time(self) -> int: ...
    @classmethod
    def from_normal_data(cls, content: NormalData) -> ExpData: ...
    @classmethod
    def from_const_data(cls, content: ConstData) -> ExpData: ...
    @classmethod
    def from_const(cls, mean: float, std: float) -> ExpData: ...
    @classmethod
    def wrapped_list_of_const_data(cls, list_constdata: List[ConstData | None], repeat_time: int) -> ExpData: ...

    def __mul__(self, other: ExpData) -> ExpData: ...
    def __rmul__(self, other: float) -> ExpData: ...
    def __truediv__(self, other: ExpData) -> ExpData: ...
    def __add__(self, other: ExpData) -> ExpData: ...
    def __sub__(self, other: ExpData) -> ExpData: ...
    def __neg__(self) -> ExpData: ...
    def __powi__(self, i: int) -> ExpData: ...
    def __diff__(self, other: ExpData) -> ExpData: ...
    def __difftau__(self) -> ExpData: ...

class NormalData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, data: List[List[float]]) -> NormalData: ...
    @classmethod
    def zero(cls, n: int, repeat_time: int) -> NormalData: ...
    @classmethod
    def from_elem(cls, mean: float, std: float, n: int, repeat_time: int) -> NormalData: ...
    @classmethod
    def from_const_data(cls, content: ConstData, n: int, repeat_time: int) -> NormalData: ...
    @classmethod
    def wrapped_list_of_const_data(cls, list_constdata: List[ConstData | None], repeat_time: int) -> NormalData: ...
    @property
    def data(self) -> List[List[float]]: ...
    @property
    def badpts(self) -> Set[int]: ...
    def is_conserved_piecewise(self) -> bool: ...
    @property
    def is_conserved(self) -> bool: ...
    @property
    def is_zero(self) -> bool: ...
    @property
    def mean(self) -> List[float]: ...
    @property
    def std(self) -> List[float]: ...
    @property
    def n(self) -> int: ...
    @property
    def repeat_time(self) -> int: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

    def __add__(self, other: NormalData) -> NormalData: ...
    def __sub__(self, other: NormalData) -> NormalData: ...
    def __mul__(self, other: NormalData) -> NormalData: ...
    def __rmul__(self, other: float) -> NormalData: ...
    def __truediv__(self, other: NormalData) -> NormalData: ...
    def __neg__(self) -> NormalData: ...
    def __powi__(self, i: int) -> NormalData: ...
    def __difftau__(self) -> NormalData: ...
    def __diff__(self, other: NormalData) -> NormalData: ...

class ConstData:
    ...
    def __str__(self) -> str: ...
    def __new__(cls, mean: float, std: float) -> ConstData: ...
    @classmethod
    def exact(cls, val: int) -> ConstData: ...

    @property
    def mean(self) -> float: ...
    @property
    def std(self) -> float: ...

    def __add__(self, other: ConstData) -> ConstData: ...
    def __sub__(self, other: ConstData) -> ConstData: ...
    def __mul__(self, other: ConstData) -> ConstData: ...
    def __rmul__(self, other: float) -> ConstData: ...
    def __truediv__(self, other: ConstData) -> ConstData: ...
    def __neg__(self) -> ConstData: ...
    def __powi__(self, i: int) -> ConstData: ...

def is_conserved_const_list(data: List[ConstData]) -> bool: ...

def is_conserved_mean_and_std(mean: List[float], std: List[float], alpha: float = 0.05) -> bool: ... 

def do_collision(m1:float, m2:float, v1:float, v2:float) -> Tuple[float, float]: ...

class sentence:
    """
    A parser for the language of the AI Physicist.
    """
    def parse_sympy_to_exp(input: str) -> Exp: ...
    def parse(input: str) -> Expression: ...
